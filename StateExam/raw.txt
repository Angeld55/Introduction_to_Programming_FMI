11. 
Процедурно програмиране 
- Стъпка по стъпка инструкции.
- Програмата се разделя на процедури/функции

1. Структурно програмиране:
 Частен случай на процедурното програмиране.
Основаната разлика е: не се използва оператор goto

2. Управляващи конструкции:
Условни оператори - 
- if - приема булево условие. Ако истина, се изпълнява кодът.
  if/else else-if

- switch - приема целочислен тип
  case x1:  break;
  case x2:  break;

Оператори за цикък: while/for/do-while
- while
- for - с водеща променлива/променливи
- Какъв проблем решава for пред while?
 - имаме водеща променлива за цикъла, която е видима само за него!!

 int i = 0;
  while(i < 100)
    cout<< i;
    i++;

- do-while - гарантира поне 1 изпълнение на тялото на цикъла.

3. Променливи:
 <тип> <име> (= <начална стойност>)
 Ако не дадем начална стойност, стойността на променливата не може да се предвиди.

- Локални променливи: 
Променлива, която е декларирана в тялото на дадена фунцкия.
Жизнен цикъл:  От нейното деклариране, до края на scope-а, в който е дефинирана.

- Глобална променлива:
Променлива, която не е декларирана в тялото на функция.

Жизнен цикъл: До края на изпълнението на програмата.
Може да се достъпват от всички процедури.

- Оператор за присвояване. (оператор=)
  
 <именована променлива> =  <именована променлива> / <литерал>
  <lvalue>			<lvalue>		<rvalue>
 a = b - променливата а присвоява стойността на променливата b.


Тип на връщане на оператора за присвояване:
 a = b - връща референция към а.
Асоциативност: Дясна

 a = b = c = d = 4   екв на a = (b = (c = (d = 4)))
 
Понеже операторът връща референция към лявата променлива, можем да chain-нем:
 a = (b = (c = (d = 4))) //d е 4
 a = (b = (c = d))  // c e 4
a = (b = c)
...


4. Функции и процедури.
деф функция: именувана група от инструкции

<тип на връщане> <име>([параметри])
{
	//тяло на функцията.
}

Видове параматри:
По стойност:
void f(int a) {...}     int x = 10; f(x); - променливата а копира съдържанието на променливата x.
!! f(5) OK!!!!

-----------По референция (по име ? ):
void f(int& a) {...}   int x = 10; f(x); - a е референция към променливата x. Всяка промянва на a в тялото на f ще бъде отразена и върху x.
!! f(5) НЕ Е OK!!!!  - Функцията f очаква именована променлива (lvalue)

Ако няма да правим промени, но не искаме да правим копие - константна референция.
void f(const int& a){...}
  f(a) OK   f(5) - тук може и неименована променлива!
 

--- ------ По указател (по име ?):
void f(int* ptr) { *ptr++;} - f(&a) - ptr е указател към стойността на a. Всяка промяна се отразява и на a. (Може указателят да бъде константен)


f(int x)   -> int a=  10; f(a);
 f(b)  (b не е променлива от тип int) - опитва се да се направи имплитно преобразуване

5. Символни низове
 - масив от символи, в който последния значещ символ е терминираща 0 ('\0')


char str[10] = "abc";
[a][b][c][\0][\0][\0][\0][\0][\0][\0]
-------------
значеща част

Низ в динамичната памет:
char* str = new char[len + 1];
strcpy(str, "abc");
//използване 
delete[] str;

Основни операции:
strlen(const char* str) - връща дължина на низ
strcpy(char* dest, const char* source) - копира низ
strcat(char* dest, const char* source) - конкатенира source към dest
strcmp(const char* lhs, const char* rhs) - лексикографско сравниение  
	lhs < rhs отр число
        lhs == rhs -
        lhs > rhs  пол число.


 

12. Процедурно програмиране – указатели, масиви и рекурсия.
1. Указатели и указателна аритметика.
Деф: Указтел - променлива, която съдържа адреса на друга променлива.

<тип>* <име> (= <стойност)

Оператор &:   &<именована променлива> - връща указател към тази променлива.

int a = 10;
int* ptr = &a;

Оператор * (дерефериране) : *<указтел> - връща стойността, към която сочи указателя.

Указтелите знаят 2 неща: Адреса към който сочат, типа на променливата!!

Указателите имат неутрална стойност (за разлика от референциите)
- nullptr

Аритметика:
T* ptr = .....

ptr += <число x> - отмества указтеля на адрес  
ptr започва да сочи на адрес: адреса на ptr + sizeof(T) * x

ptr + 7 - прави същото, но не променя ptr, а връща нов указател.

ptr++;
++ptr; // отместват Ptr с sizeof(T)

Пример: 
Индексиране на масив с указателна аритметика:
arr[i]  <=>  *(arr + i)

Съществува void указател;
void* ptr - може да сочи към променлива от произволен тип.
Нямате указателна аритметика, не може да се дереферира!!



2. 
Едномерни масиви:
<тип> <име>[размер]; - размерът трябва да е известен повреме на компилация!!!

- променливите са последователно разположени в паметта!
arr[i] - достъп от i -ти елемтн
Индексите са {0 ... размер - 1}

int arr[10]  
като напишем arr - преобразува към указател към първия елемент на масива!
arr[i] - колко пъти да се отмести надясно.



Динамични масиви - размерът може да е променлива, чиято стойност се определя повреме на изпълнение:
int* ptr = new arr[N]  ptr -  Е УКАЗТЕЛ към първия елемент.
delete[] ptr;

Многомерен масив:

int m[size1][size2] - едномерен масив, на който елементите му са масиви
int m[3][4] - масив с 3 елемента - всеки елелемент е масив с 4 числа.
[ [][][][] ] [ [][][][] ]  [[][][][]]

В паметта: int arr[12]  <-> int m[3][4] 
Плюс: Двойна индексация

int** matrix = new int*[rowsCount]
for(int i = 0; i < rowsCount; i++)
   matrix[i] = new int[currCollSize] //може да е различна за всеки ред

for(int i = 0; i < rowsCount; i++
   delete[] matrix[i];  //не ви трябва размера на колоната
delete[] matrix;

Сортиране и търсене в едномерен масив – основни алгоритми
- линейно търсене - сложности: O(n)
- двоично търсене (сортиран масива): O(log(n))

- Мехурчето/пряка селекция/вмъкване 

Рекурсия – пряка и косвена рекурсия, линейна и разклонена рекурсия.

Функция, която извиква сама себе си.
Пряка: f Извиква директно f
Косвена: f извиква друга функция, която извиква f пряко или косвено.

линейна -> има едно рекурсивно извикване:
 линеен рекурсивен процес: Факториел
	
Може да се оптимизира с опашкова рекурсия:
Последното действие на функцията е рекурсивното извикване!!!!

void fact(int n, int res)
{
	if(n == 0)
		return res;
	return fact(n - 1, res * n);
}

разклонена рекурсия - повече от едно рек. извикване:
Пример Фибоначи!


13. 
- Абстракция със структури от данни: 
Разделянето на представянето и използването на дадена структура от данни.
Позволява използването преди представянето да е уточнено!!

- Класове и обекти:
Клас/Структура:  Съвкупност от функции и променливи, които са обвързани в обща логическа структура.
Обект/Инстанция: Съвкупност от елементи и тяхното поведение


Структура -> инстанция
Класове -> обект

class Point
{
	int x;
	int y;
        void print() const { cout << x << " " << y << endl}
}
//Член-функции се дефинират като конст, ако няма да променят член-данните!

Можем да правим обекти от този клас:
Point p1; //<име на класа> <име на обект>;

Основни видове конструктори: 
- Контруктор по подразбиране - Конструктор без параметри.
Ако няма други експлицтно разписани контрструктори, то може да използваме такъв за създаване на обекти. Можем и ние да разпишем деф. конструктор.

A arr[10] / new A[10] -> извиква се 10 пъти контструктор по подразбиране
Ако нямаме такъв конструктор, не можем да създадем масив по този начин.

- Конструктор за копиране:
 A(const A& other) - текущият обект да стане копие на подадения.

 Пример за извикавне:
 f(A obj){}
 A obj1;
 A obj2(obj1); //c.c.;
 A obj3 = obj1; // c.c
 f(obj1) //c.c}

- Комплилаторът генерира деф такъв, ако не сме разписали еклплицитно:
   копиращ конструктор или move конструктор

class X
{
 	A obj;
	B obj2;
} 
Генерирания К.К на X извиква К.К на А и B

- Конструктор зa местене: (за красота)


  A(A&&)
- Комплилаторът генерира деф такъв, ако не сме разписали еклплицитно:
   копиращ конструктор или move конструктор


Управление на динамичната памет и ресурсите (“RAII”)
RAII -  Resource Acquisition Is Initialization 
 - ако обект използва външни ресурси/дин памет, то 
тяхният жизнен цикъл да е обвързан с жизнения цикъл на обекта!!!
Пример за класове, които НЕ са RAII:
 Функция: close()/open();  lock()/unlock()

Най-честа имплементация: Заделяне на памет/отваряне на ресурса в контрструктра.
			 Изтриване/затваря на ресурса в деструктора.

При външен ресурс, се налага експлицитното имплементиране на к.к и оператор за присояване.

 
Методи – декларация, предаване на параметри, връщане на резултат

class Test
{
	<тип на връщане> <име>(<параметри>)
}
Член-функциите имат достъп до всички полета на класа.
Член-функциите се преобразуват до външни функции, но с един допълнителен параметър:  Указтел към обекта, от който извикана функцията: Той се нарича this.


Наследяване. Производни и вложени класове. Достъп до наследените
компоненти. Капсулация и скриване на информацията. Статични полета и
методи.


- Наследяване: Може клас да наследи друг клас:
Класът насленик взима всички свойства и членове на класа-родител.

class Der : Base
{

}

Достъп до наследените компоненти:
Модификатори на членове на клас:
- private - достъп само в класа
- protected - достъп в класа и наследниците му
- public - достъп отвсякъде.

3 вида наследяване: public/protected/private (по подразбиране в класовете е private, а в структурите е public)

class A 
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A    // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
вложени класове: класове, които са дефинирани в Scope-а на друг клас:
struct Triangle
{
	struct Point
	{
		int x;
		int y;
	};
};
Triangle::Point p;
*ако имате предвид композиция: 

Капсулация и скриване на информацията:
Капсулация: Ограничаване на достъпа
Постига се чрез модификатори за достъп: 

Ако контролиран достъп до член-променлива:
Сeлектори и мутатори
Селекторите: Връщат копие/констр реф/конст указател към данните
Мутаторите: Модифицират, но под контрол

class X 
{
	int a;
	public:
        void setA(int newA) {//проверки за валидност}
        int getA() const{return a;}
}
Статични полета и методи.
- Полета и методи, които не са обвързани с конкретен обект.


struct Test
{
	public:
	int a;
	static int b;
	void f(){}
	static void g(){}
};

int Test::b = 10;

Test::b++;
Test::g();
Статичните методи имат достъп само до другите другите статични методи и статични променливи, но не и до нестатичните такива (освен ако не създадем обект вътре).

14:

14: 
Полиморфизъм: 1 име, но различни имплементации

Статично свързване: Изборът на ф-я става повреме на компилция: презаписване на функции(function overloading)

Динамично свързване: Изборът на ф-я става повреме на изпълнение: Постига се чрез виртуални функции:


struct Base
{
	void f() const { print 1};
	virtual void g() const { print A};

};

struct Der : Base
{
	void f() const { print 2};
	virtual void g() override const { print B};
};

void f(const Base& ref)
	ref.f();
        ref.g();


Der d;
f(d);  // 1 (статично свързване) / B (динамично свързване)

override - да се направи проверка компилатора за синтаксиса на презаписаната функция

Абстрактен метод:
- метод, който трябва да се презапише от всеки неабстрактен наследник.

struct X {virtual void f() = 0;} 

- Абстрактен клас: Клас, който има поне един абстрактен метод или не презаписва абстрактен метод от базов клас.

Масиви от обекти и от указатели към обекти.
	Base  
 A        B        C

Хетерогенен контейнер - контейнер от указатели към базовия клас. 
Container
{
	Base** data;
}
Работим абстрактно без да се интересуваме какъв тип са обектите!!!!

Триене:
  for(int i = 0; i < size; i++)
	delete data[i]; //

!! За да работи коректно триенето, трябва деструктор в базовия клас да бъде деклариран 
като виртуален!!!!!!!!

Копиране:
 - чрез prototype design pattern
- чисто виртуална функция clone в базовия клас.
- Всеки наследник я имплементира и връща копие на себе си.	

   data = new Base*[other.size];
   for(int i = 0; i < other.size; i++)
	data[i] = other.data[i]->clone();
  

Параметричен полиморфизъм. Шаблони на функция и на клас
Параметричен полиморфизъм - една и съща имплементация незвисимо от типовете!!

Пример за шаблонна функция:

template <class T>
const T& max(const T& lhs, const T& rhs)
 	return lhs < rhs ? rhs : lhs;

max<int>(3,4):
max<std::string>("dsf", "werew"); 


- комплаторът създава код за всеки тип, с който е извикана функцията!!
- Трява да сме сигурни, че във функцията се използват само позволени за съотвения тип операции.

Можем да създаваме и шаблонни класове:

template <class T>
class Vector
{
	T* data;
        size_t cap;
	size_t size;
}


Шаблонна специализация:
Клас/фунцкия, която се държи различно за определени типове:
Пример std::vector<bool> - битсет (memory efficient)

Множествено наследяване
Един клас може да има повече от един базов клас;

Base1  Base2
    Der 

Отново може да насочваме указтели/референции от тип base1/base2 към Der (въпреки, че началото на обектите Der и  base2 не съвпадат)


Може да се получи двусмицлица:

Base1    Base2
  f()     f()
      Der f() - наследява се 2 пъти!



Диамантен "проблем":

    A
 B     C
    D  

В обекта от тип D има две инстанции на A !!

Решение: Чрез виртуално наследяване.
X : virtual Y -> Всеки наследник на X е отговорен за извикването на конструктор на Y

    A
B : virtual A    C: virtual A
  D : B, C     - Една инстанция на А, за която е отговорен D


